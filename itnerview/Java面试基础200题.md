一、Java 基础
---

1.JDK 和 JRE 有什么区别？
-  JDK包含了JRE，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的，包含编译器；
-  JRE是java运行时环境，包含了java虚拟机，java基础类库

2.== 和 equals 的区别是什么？
- 前者针对存储地址的比较，后者则针对对象内容；
- (== -> true) -> (.equals() -> true)

3.两个对象的hashCode()相同，则 equals()也一定为 true，对吗？ 
- 不对；
- 对象相同，hashcode()一定相同；
- hashcode()不相同，对象一定不同
- 因此，对象不相同，hashcode()不一定不相同；

4.final 在 java 中有什么作用？
- 修饰成员变量，表示变量不可被赋值，而且必须要有初始值，分引用变量和基本数据变量两种情况；
- 修饰方法，表示这个方法不可被重写(可继承)；
- 修饰类，表示这个类不可以被继承

5.java 中的 Math.round(-1.5) 等于多少？
- -1.5 + 0.5 =↓=> -1 

6.String属于基础的数据类型吗？
- 否

7.java 中操作字符串都有哪些类？它们之间有什么区别？
- StringBuffer 线程安全的；
- StringBuilder 非线程安全；

8.String str="i"与 String str=new String("i")一样吗？
- 否，后者会产生垃圾，并且JDK8后，是存储于堆区的，而前者是放在元数据区域的；new是不会自动入池，注意手动入池是会失败的

9.如何将字符串反转？
- 调用reverse()方法

10.String 类的常用方法都有那些？
- "+" 和concat()
- SubString()
- replace()
- replaceAll()
- charAt()
- IndexOf()
- length()
- 
- 围绕增删查改、最后是大小写

11.抽象类必须要有抽象方法吗？
- 否


12.普通类和抽象类有哪些区别？
- 抽象类无法直接实例化；
- 抽象方法跟普通方法的区别
- 子类如果没有实现所有抽象方法，也必须为抽象类


13.抽象类能使用 final 修饰吗？
- 否

14.接口和抽象类有什么区别?(关键字，变量，方法，使用差异)
- implements 和 extends
- 接口的变量默认 public static final 的公有变量；
- 抽象类可以有普通方法，私有变量，私有方法等；
- 接口可以使用extends实现多个继承；

15.java 中 IO 流分为几种？
- Java中的流分为两种，一种是字节流，另一种是字符流，分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的.

16.BIO、NIO、AIO 有什么区别？
- ==BIO==是传统的流操作：
- InputStream,OutputStream,Reader,Writer，通过把数据拷贝到用户空间内实现的；
- ==NIO==：构建多路复用的同步非阻塞的的IO操作(提供了更贴近操作系统的数据操作方式)：
- 反复检查操作系统对应获取的数据是否准备好，如果准备好了就拷贝；
- Channels,Buffers,Selectors
- FileChannel(拷贝不需要转换为内核态),DatagramChannel,SocketChannel,ServerSocketChannel
- 八大基础类型的Buffer
- selector，用于分配线程资源Thread去处理不同的channel,channel直接负责buffer
- ==AIO==：异步IO的操作基于事件和回调机制；是NIO的升级，实现了异步非阻塞IO； //TODO


17.Files的常用方法都有哪些？
- Files.exists() 检测文件路径是否存在
- Files.createFile()创建文件
- Files.createDirectory()创建文件夹
- Files.delete() 删除文件或者目录
- Files.copy() 复制文件
- Files.move() 移动文件
- Files.size（）查看文件个数
- Files.read() 读取文件
- Files.write()写入文件



二、容器
---

18.java 容器（这里指集合）都有哪些？
- ~~Tomcat~~
- ~~Docker~~
- Collection
- Map
- Iterator


19.Collection 和 Collections 有什么区别？
- 前置是接口，后者是给实现了Collection接口的对象提供一些使用的方法，譬如最常用的sort方法；

20.List、Set、Map 之间的区别是什么？
- 链表，集合，表；
- 链表：通过指针连接的元素，有序；
- 集合：无重复元素，无序；
- 表：具有O(1)的查找性能的一个集合；通过求哈希值来查找对应数据；存放的是键值对；

21.HashMap 和 Hashtable 有什么区别？
- 前者非线程安全，后者线程安全；
- ConcurrentHashMap和HashMap一样都是采用拉链法处理哈希冲突，且都为了防止单链表过长影响查询效率，所以当链表长度超过某一个值时候将用红黑树代替链表进行存储，采用了数组+链表+红黑树的结构

22.如何决定使用 HashMap 还是 TreeMap？
- 首先根据用途去分析，譬如做缓存，还是做数据持久化贮存；
- 根据查找数据的数据量来进行决定；

23.说一下 HashMap 的实现原理？
- 以键值对作为基本的存储单位；
- 通过计算Key来实现高速存取Value

24.说一下 HashSet 的实现原理？(去重复)
- 存取的时候会计算hashCode()；如果相同，则调用equals()来进行进一步分析；

25.ArrayList 和 LinkedList 的区别是什么？
- 前者实现基于数组，后者基于链表
- 前者读取的速度会比后者快很多，但是插入数据的时候(大量，无序)，会因为内存的申请，和数组复制，导致性能下降；
- 后者的存储速度会更快，因为链表插入数据的特性；

26.如何实现数组和 List 之间的转换？
- 使用Arrays.asList()来进行；
- 后者使用List.toArray(T a[])来进行;返回对应的类数组
- 如果涉及基本数据类型，则需要使用包装类进行操作

27.ArrayList 和 Vector 的区别是什么？
- 后者是线程安全的 TODO

28.Array 和 ArrayList 有何区别？
- 后者是Java基本类库的提供的一个集合，有对数组的各种操作的方法，以及会自动给数组进行扩容；
- 常用方法：(增删查改比较反转)
- add()
- addAll()
- clear()
- remove(int index)
- set(int index,E element)
- size()
- toArray() 返回Object[]数组
- toArray(T[] a) 指定返回的数组类型
- Array是数组，有固定容量，但无法得知具体储存的元素的个数
- Arrays是Java的一个标准类库，提供对数组的一些操作方法，譬如反转，排序等...
- equals（）比较所有的元素是否数量和内容相同
- sort()排序
- binarySearch()用来对已排序的array查找元素
- 

29.在 Queue 中 poll()和 remove()有什么区别？
- poll()删除空元素会返回null
- remove()删除空元素会抛异常


30.哪些集合类是线程安全的？
- Hashtable
- concurrentHashMap
- Vector
- StringBuffer(不是集合类)


31.迭代器 Iterator 是什么？
- 用于对实现了Iterable接口的集合类进行迭代的一次性使用的实例对象；可用于对数据进行查询获取删除等操作；

32.Iterator 怎么使用？有什么特点？
- 调用iterator()方法，返回一个Iterator对象，调用其next()返回集合中的元素；

33.Iterator 和 ListIterator 有什么区别？
- listIterator()仅存在list接口或者实现类中；
- iterator()还存在set()接口；
- listIterator()可以向List中添加元素；
- listIterator()有hasPrevious()和previous()方法，可以逆序；
- 还可以使用nextIndex()和previousIndex()定位索引位置；
- 

34.怎么确保一个集合不能被修改？
- 使用private封装，使一个类持有该集合，并且只实现get()方法；


三、多线程
---

35.并行和并发有什么区别？
- 并行的同一时刻同时运行多个程序；
- 并发是同一时间段内运行多段程序；

36.线程和进程的区别？
- 进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位；
- 进程之间有独立的代码和数据空间，进程间切换开销较大；
- 线程是进程的一部分，也可称为轻量级进程，==线程之间共享同一进程的资源==，而==每个线程都有自己独立的运行栈和程序计数器(PC)==
- 线程之间的==切换开销小==；
- 操作系统中能==同时(并发)(多核则是并行)运行==多个进程，而一个进程中有多个线程同时执行(通过CPU调度，每个时间片中只有一个线程执行(并发))

37.守护线程是什么？
- 当==被==守护线程完成时，守护线程便会终止运行；
- 最大的守护线程是GC


38.创建线程有哪几种方式？
- 继承Thread类，并且重写run()方法，调用start()方法
- 实现Runnable接口，并实现run()方法，并通过实例化Thread类来运行这个类对象；
- 实现Callable接口，实现call方法，FutureTask封装后通过Thread方法递交

39.说一下 runnable 和 callable 有什么区别？
- runnnale接口无法抛出非RuntimeExection的异常
- callable接口运行时会返回一个对象Future，用于检测线程运行情况；并且可以获取他的返回结果
- 执行方法，使用方法如下
```
class MyCallable  implement callable{ ···call()···}
FutureTask<AnyType> task233 = new FutureTask<> (new MyCallable() );
// implemented是伪代码
new Thread(task233).start();//返回Future实例对象
也可以submit方法递交给线程池执行；
```



40.线程有哪些状态？
- NEW 尚未启动
- RUNNABLE 正在执行中
- BLOCKED 阻塞的 (被同步锁或者IO锁阻塞)
- WAITING 永久等待状态
- TIMED_WAITING 等待指定的时间重新被唤醒的状态
- TERMINATED 执行完成

41.sleep() 和 wait() 有什么区别？
- 前者释放锁、后者不释放锁
- 前者是Thread类的方法，后者是Object的方法
- 前者通过interrupt()方法中断，后者通过notify,notifyAll方法中断
- sleep()不释放锁；wait()释放锁；
- 

42.notify()和 notifyAll()有什么区别？
- 前者是随机唤醒一个线程，后者是唤醒全部线程；
- 因此wait()是用于针对线程共享的那个临界区资源；

43.线程的 run()和 start()有什么区别？
- run()方法只是运行普通的方法，不具有多线程的特性，不是异步执行的；会阻塞当前线程的运行
- 后者是把该对象交给一个线程管理数组来进行运行的；

44.创建线程池有哪几种方式？
- 利用Executors.newFixedThreadPool(int nThreads)，指定最多n个线程工作
- Executors.newCachedThreadPool()，用于处理大量短时间工作任务的线程池：它会试图缓存线程并==重用==，线程闲置超时会移出缓存，这种线程池长时间闲置时不会消耗很多资源；
- newSingleThreadExecutor();该线程池的工作线程数目被限制为1，操作一个无界的工作队列，保证了所有的任务都是==顺序执行==的，最多会有一个任务处于活动状态，并且不允许使用者改动线程池里的的实例；
- newScheduledThreadPool(int corePoolSize)：可以定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；
- newWorkStealingPool(int parellelism) :这是一个经常被人忽略的线程池，java8才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；
- ThreadPoolExecutor()是最原始的线程池创建；上1-3均为它的封装
- 

45.线程池都有哪些状态？
- RUNNING：最正常的状态，接受新的任务，处理等待队列中的任务
- SHUTDOWN：不接受新的任务递交，但是会继续处理等待队列中的任务
- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程；
- TIDYING：所有的的任务都销毁了，workCount为0，线程池的状态在转换为TIDYING状态时，会执行钩子方法terminated()；
- TERMINATED：terminated方法结束后的状态

46.线程池中 submit()和 execute()方法有什么区别？
- 前者是ExecutorService接口里面的方法，具有返回值，可对线程的执行情况进行监控，拥有比execute更完善的功能，也更方便非RuntimeExcepion的处理
- 后者无返回值，只能执行Runnable类型的任务


47.在java程序中怎么保证多线程的运行安全？
- 方法一：使用安全类，比如Java.util.concurrent下的类；
- 方法二：使用自动锁synchronized；
- 方法三：使用手动锁Lock;
```
/**
 *手动使用锁
 /
Lock lock = new ReentrantLock();
lock.lock();
try{
    System.out.println("获得锁");
}catch(Exception e){
    // TODO 
}finally{
    lock.unlock();
    System.out.println("释放锁")
}
```

48.多线程锁的升级原理是什么？
---
- 根据竞争资源的线程数上升，要升级锁的力度；
- 通过==修改锁对象的对象头==标志头Mark word的锁标志位(threadid)，是否偏向锁来进行,首先判断threadid和线程id是否一致，一致则可以直接使用该对象，如果不一致，则升级为轻量级锁：自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁；
- 偏向锁：该锁偏向于第一个获得它的线程，在接下来的执行过程中 ，假如该锁==没有被其他线程获取和竞争==，则持有该锁的线程将不会进行同步操作；(==进出该段代码无需加锁释放锁==)；可以理解为编译器检查Mark word 锁标志位，如果ThreadId相同切当前是偏向锁，则可以省去大量有关锁申请的操作；不适用于锁竞争激烈的情况；
- 多竞争就会升级为膨胀锁 -- 一个轻量级锁
- 轻量级锁也被称为==非阻塞同步、乐观锁==，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。适用于线程交替执行同步块或方法的场景
- Java使用的轻量锁是(自适应)自旋锁
- 轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。
- MySQL使用的乐观锁是通过版本号来进行的，核心思想是，某操作的数据一般认为只有这个线程在操作，就是说，在数据真正准备写入的时候，才进行锁的竞争；
- 轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖==对象内部的monitor锁==来实现的，而monitor又依赖==操作系统的MutexLock(互斥锁)来==实现的，所以重量级锁也被称为==互斥锁==。适用于追求吞吐量、同步块或者同步方法执行时间较长的场景；
- 也就是说，synchronized关键字并非一开始就该对象加上重量级锁，也是从偏向锁，轻量级锁，再到重量级锁的过程。



49.什么是死锁？
- 共同抢占同一个临界资源并且均处于无法运行的状态；
- 即相互持有对方需要的锁，而发生阻塞现象；

50.怎么防止死锁？

- 设置锁超时；
- 使用Java.util.concurrent并发类代替自己手写锁。
- 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。
- 尽量减少同步的代码块
- 

51.ThreadLocal 是什么？有哪些使用场景？
- 是给每个使用该变量的线程提供独立的变量副本，所以每一个线程懂可以独立地改变自己的副本，而不会影响其他线程所对应的副本；
- 经典使用场景是数据库连接和session的管理；

52.说一下 synchronized 底层实现原理？
- 由一对monitorenter/monitorexit指令实现的，monitor对象是同步的基本实现单元。在Java 6之前，monitor的实现完全依赖于操作系统内部的互斥锁，因此会从用户态切换为内核态，因此为无差别重量级操作，性能也很低；但是在Java 6以及之后，提供了三种不同monitor实现，也就是常说的三种不同的的锁：偏向锁、轻量级锁、重量级锁；
- 无锁、偏向锁、轻量级锁、重量级锁
- 

53.synchronized 和 volatile 的区别是什么？
- 线程安全的两个方面：执行控制和内存可见;
- volatile是变量修饰符；synchronized是修饰类、方法、代码段；
- volatile技能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性；
- volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化


54.synchronized 和 ReentrantLock 有什么区别？
- ReentrantLock称为再入锁，何以实现比synchronized更细粒度的控制，譬如fairness;
- 必须手动获取锁和释放锁
- 也是可重入的，但未必性能更高
- 公平性：偏向把锁赋予等待时间最长的线程
- 公平锁：获取锁按调用lock的先后
- 判断是否有线程，或者某个特定线程，在线等候获取锁
- 前者是关键字，后者是类；
- ReentrantLock可以获取各种锁的信息，灵活实现多路通知；
- ReentrantLock可对锁的等待时间进行设置，避免死锁；
- synchronized操作对象头的MarkWord，ReentrantLock调用lock的再调用Unsafe类的park方法；

55.synchronized 和 Lock 区别是什么？ 
- synchronized可以给类、方法、代码块加锁，而lock只能给代码块加锁。
- synchronized不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；
- lock需要手动加锁和释放锁，如果使用不当，没有unlock()就会造成死锁
- 

56.说一下 atomic 的原理？
- 利用CAS（乐观锁）和volatile和native方法来保证原子操作，从而避免synchronized的的高开销，提高效率；
- 通过unsafe类直接操作内存
- 

四、反射

57.什么是反射？
- 可以在运行状态中，动态加载类和实例化类和调用方法变量甚至私有方法和变量；获取任意一个类的所有属性和方法；

58.什么是 java 序列化？什么情况下需要序列化？
- 以对象为单位的传输通信；
- 以对象为单位的持久化存储(本地硬盘或数据库)；
- 想通过RMI(远程方法调用)传输对象的时候
- 

59.动态代理是什么？有哪些应用？
- 运行时动态生成代理类
- 应用有Spring aop、hibernate数据查询，测试框架的后端mock、rpc、Java注解对象的获取等；


60.怎么实现动态代理？
- JDK Proxy ：基于接口实现
- cglib ：基于继承当前类的子类实现的


五、对象拷贝

61.为什么要使用克隆？
- 被克隆的对象可能包含一些已经修改过的属性，而new出来的对象属性都还是初始化的值，所以当需要一个新的的对象来保存当前对象的“状态”就靠克隆方法了；

62.如何实现对象克隆？
- 实现Cloneable接口并重写Object类中的clone()方法。
- 实现Serializable结构，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆；

63.深拷贝和浅拷贝区别是什么？
- 浅克隆：不复制引用对象，只针对引用本身进行复制
- 深克隆：引用及引用的对象均会被克隆；

六、Java Web

64.jsp 和 servlet 有什么区别？
- JSP是 servlet技术的扩展，本质就是servlet的简易方式。servlet和JSP最主要的不同点在于，servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来，而jsp的情况是Java和HTML可以组合成一个扩展名为JSP的文件；

65.jsp 有哪些内置对象？作用分别是什么？
- request：封装客户端的请求，包括get和post请求的参数
- response：封装服务器对客户端的响应；
- session：封装用户会话的对象
- application 即 servletContext：封装服务器运行环境的对象
- page 即 this：指JSP页面本身
- servletConfig：Web应用的配置对象
- out：输出服务器相应的输出流对象；
- exception：封装页面抛出的异常对象
- pageContext：通过该对象可以获取其他对象

66.说一下 jsp 的 4 种作用域？
- page：代表一个与页面相关的对象和属性
- request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以设置于此作用域
- session：代表与某个用户和服务器简历的一次会话相关的对象和属性。跟某个用户相关的数据应放在用户自己的session中。
- application：跨越整个Web应用程序的作用于；

67.session 和 cookie 有什么区别？
- 存储位置不同：
- cookie在服务器端生成，存放于客户端，并每次访问的时候随着请求返回
- session通过生成sessionID ，是存放在服务器端的
- 安全性不同：
- cookie安全性一般，可被伪造，session不可被伪造；
- 容量和个数限制：cookie有容量限制，每个站点下的cookie也有个数限制
- 存储的多样性：session可以存储在Redis中，数据库中，应用程序中；cookie只能存储在浏览器中；
- 

68.说一下 session 的工作原理？
- 客户端完成登录后，服务器会创建对应的session，session创建完之后，会把session的id发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着sessionID，服务器拿到sessionID之后，在内存寻找对应的session对象，存取对应的数据；

69.如果客户端禁止 cookie 能实现 session 还能用吗？
- 可以，可以把对应的sessionid信息存放在URL里，每一次的访问都携带这个信息就可以了

70.spring mvc 和 struts 的区别是什么？
- spring MVC 继承了ajax，使用注解@ResponseBody即可；
- spring有aop

71.如何避免 sql 注入？
- 使用预处理PreparedStatement
- 使用正则表达式过滤掉字符中的特殊字段；


72.什么是 XSS 攻击，如何避免？
- XSS攻击：即跨站脚本攻击，原理是往Web页面里插入恶意的脚本代码(CSS,JavaScript代码等)，当用户浏览该页面时，其中的代码会被执行，从而达到了恶意攻击用户的目的，譬如盗取cookie、破坏页面结构、重定向到其他网站等；
- 预防措施是必须对输入的数据做过滤的处理；

73.什么是 CSRF 攻击，如何避免？
- CSRF：Cross-Site Request Forgery(跨站请求伪造)，即攻击者盗用身份发送恶意请求；

七、异常

74.throw 和 throws 的区别？
- throw 指抛出类的异常
- throws 指可能抛出的类或及类的范围
- 

75.final、finally、finalize 有什么区别？
- final：修饰类，方法，变量，分别表示，不可继承，不可重写，不可赋值或修改引用；

76.try-catch-finally 中哪个部分可以省略？
finally和catch都可以省略，但是不能同时省略；try后必须有两者其一；

77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
- 会，catch中的return 会等待finally执行完毕再执行

78.常见的异常类有哪些？
- NullPointerException 空指针异常
- ClassNotFoundException 指定类不存在
- NumberFormatException 字符串转换为数字异常
- IndexOutOfBoundsException 数组下标越界
- ClassCastException 数据类型转换异常
- FileNotFoundException 文件未找到异常
- NoSuckMethodException 方法不存在异常
- IOException IO异常
- SocketException Socket异常

八、网络

79.http 响应码 301 和 302 代表的是什么？有什么区别？
- 301：永久重定向
- 302：暂时重定向
- 前者对搜索引擎优化有利，后者会有被网络拦截的风险

80.forward 和 redirect 的区别？
- 地址栏url显示：forward不会改变，redirect会改变；
- 数据共享：forward可以共享request里的数据，redirect没有，只能借助session
- 效率：forward比redirect高；因为是内部转发；

81.简述 tcp 和 udp的区别？

TCP | UDP
:---:|:---:
面向连接 | 无连接
 可靠 | 不可靠
 有序 | 无序
 慢(数据量少) | 快(数据量少)
 重量级 | 轻量级



82.tcp 为什么要三次握手，两次不行吗？为什么？
- 如果只有两次的话，服务器端的初始化的seq无法确认已被客户端收到；
- 采用三次握手，可知道如果客户端没有响应，则视为不打开链接；
- 


83.说一下 tcp粘包是怎么产生的？
- 两种情况下会发生粘包。

>发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）

>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）

84.OSI 的七层模型都有哪些？
- 物理层：物理传输介质，基于比特流；
- 数据链路层：负责建立和管理节点的链路；
- 网络层：通过路由选择算法，为报文或分组通过通信子网选择适当的路径
- 传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输
- 应用层(
- 会话层(建立连接) 
- 表示层(加密解密，翻译) 
- 应用层(直接为用户提供服务))


85.get 和 post 请求有哪些区别？
- get是幂等的，post是非幂等的；
- get请求会被浏览器主动缓存(需要ctrl+F5)，而post不会；
- 前者递交的信息明文存放在URL，后者存放在HTTP数据报文内容中
- get传递参数有大小限制；

86.如何实现跨域？
- jQuery使用 $.getJSON，或者$.ajax发送JSONP数据； 
- 服务器端运行跨域，设置CORS等于“ * ”
- 使用@CrossOrigin注解

87.说一下 JSONP 实现原理？
- 利用script标签的src连接可以访问不同源的特性，加载远程返回的“JS函数”来执行的；


九、设计模式

88.说一下你熟悉的设计模式？
- 单例模式：保证被创建一次，节省系统开销
- Spring使用工厂模式+依赖注入实现IOC容器
- 观察者模式：定义了对象之间的一对多的依赖，当主要对象改变，所有依赖对象都会收到通知并自动更新
- 外观模式：提供一个统一的接口，用于访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用
- 模版方法模式：定义了一个算法的骨架，将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤
- 状态模式：允许对象在内部状态改变时改变它的行为，令对象看起来好像修改了它的类；

89.简单工厂和抽象工厂有什么区别？
- 简单工厂：用于生产同一等级结构中的任意产品，无法增加新产品
- 工厂方法：用于生产同一等级结构中的固定产品，支持增加任意产品
- 抽象工厂：用于生产不同产品族的全部产品，支持增加产品族；


十、Spring/Spring MVC

90.为什么要使用 spring？
- 提供IOC技术，帮助管理依赖的对象，不需要自己创建和管理；解耦
- 提供事务支持，使得事务操作变得更加方便
- 提供面向切面编程，这样可以更方便的处理某一类的问题，如日志，安全问题；
- 更方便的框架继承，spring可以很方便的集成其他框架，比如mybatis，hibernate

91.解释一下什么是 aop？
- 面向切面变成，通过预编译方式，和运行期间动态代理实现程序功能和统一维护的一种技术。
- 譬如统一处理日志，安全，异常等。

92.解释一下什么是 ioc(控制反转)？
- Spring Core的核心思想(对象的创建交给第三方管理)
- 底层：DI依赖注入Bean，可以有效地实现解耦(上层建筑依赖底层建筑)，反转后，把底层类传进上层类，实现上层对下层的"控制"，
- setter,Interface,Constructor,Annotation
- 可避免到处使用new来创建类，并且可以做到统一维护

93.spring 有哪些主要模块？
- Spring-core：框架的最基础部分，提供IOC和依赖注入特性。
- Spring-bean：
- Spring-context：构建于core封装包基础上context封装包，提供了一种框架式的对象访问方法。
- Spring-WebMVC：spring中的MVC封装包提供了Web应用的Model-View-Controller的实现。
- Spring-aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。
- Spring-tx
- Spring-jdbc：提供了JDBC的抽象层
- 
> https://blog.csdn.net/qq_41247433/article/details/79441088

94.spring常用的注入方式有哪些？
- setter注入
- 构造函数注入
- 注解注入
- 

95.spring 中的 bean 是线程安全的吗？
- Spring中的bean默认是单例模式，spring框架并没有对单例bean进行多线程的封装处理。
- 通过修改bean的作用域，譬如把“singleton”变更为“prototype”，这样请求bean相当于new Bean()了，就可以保证线程安全了；
- 有状态就是有数据存储功能；
- 无状态就是不会保存数据

96.spring 支持几种 bean 的作用域？
- singleton：spring ioc 容器中指存在一个bean实例，bean以单例模式存在，是系统默认值；
- prototype：每次从容器调用bean时都会创建一个新的对象；(即new)，(频繁的对象创建销毁，开销巨大)
- Web环境下的作用域：
- request：每次http请求都会创建一个bean实例；
- session：同一个http session 共享一个bean实例
- global-session：用于portlet容器，因为每个portlet有单独的session，提供一个全局性的http-session

97.spring 自动装配 bean 有哪些方式？
- no：默认值，表示没有自动装备，应使用==显式bean引用==进行装配
- byName：它根据bean的名称注入对象依赖项
- byType：它根据类型注入对象依赖项
- 构造函数：通过构造函数来注入依赖项，需要设置大量的参数
- autodetect：容器通过==构造函数==使用autowire装配，如果失败，则通过byType装配；
- 

98.spring 事务实现方式有哪些？
- 声明式事务：基于xml配置文件的方式，和注解方式(@Transaction注解)
- 编码方式：提供编码的形式管理和维护事务

99.说一下 spring 的事务隔离？
- 五大隔离级别
- 默认：ISOLATION_DEFAULT(使用数据库的设置)
- ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取
- ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；
- ISOLATION_REPEATABLE_READ：可重复读，保证多次读取到同一个数据时，值和开始的时候都是一致的，禁止读取到别的事务的未提交数据；
- ISOLATION_SERIALIZABLE：序列化，代价最高的可靠隔离级别；
- 
隔离级别 | 更新丢失 | 脏读 | 不可重复读 | 幻读
---|:---:|:---:|:---:|:---: 
读==未==提交 | √ | × | ×| ×
读==已==提交 | √ | √ | × | ×
可重复读(默认) | √ | √ | √ | ×
串行化 | √ | √ | √ | √

- 脏读：某事务可读取另一个未提交事务的数据；(有被回滚的风险)
- 不可重复读：在==同一个事务里==内读同一个数据，却有不同的结果；
- 脏读：==同一个事务==在修改数据、删除数据的时候、操作的数据数量跟预想中不一致；

>幻读和不可重复读的不同点：不可重复读侧重于同行数据；
而幻读侧重于不同行的数据(更多出现在增和删)

100.说一下 spring mvc 运行流程？
- 容器把接收到的http请求转发给DispathcherServlet；
- DispatcherServlet查询HandlerMapping，找到匹配的Controller；
- DispatcherServlet把请求转发到对应的Controller
- Controller业务逻辑处理完，封装数据为一个ModelAndView并返回
- Dispatcher根据ModelAndView指定的路径，查询一个或多个ViewResolver视图解析器；或者直接返回浏览器端，用JavaScript渲染
- 视图((JSP,FreeMaker) )渲染完毕后，返回给客户端


101.spring mvc 有哪些组件？
- 前置控制器：DispatcherServlet
- 映射处理器：HandlerMapping
- 处理器：Controller
- 模型和视图：ModelAndView (非必要)
- 视图解析器：ViewResolver (非必要)


102.@RequestMapping 的作用是什么？
- 将http请求映射到相应的类/方法上；

103.@Autowired 的作用是什么？
- 可对类成员变量、方法、构造函数进行注解，完成自动装配的工作
- 无需另外使用set/get来建立依赖关系

十一、Spring Boot/Spring Cloud

104.什么是 spring boot？
- 用于简化spring应用项目的搭建和开发过程

105.为什么要用 spring boot？
- 配置简单
- 独立运行
- 自动装配
- 无代码生成和xml配置
- 提供应用监控
- 易上手
- 提升开发效率

106.spring boot 核心配置文件是什么？
- bootstrap(.yml) (优先于后者)
- application(.yml)

107.spring boot 配置文件有哪几种类型？它们有什么区别？
- .yml；使用冒号":" 和缩进来表示
- .properties；使用"="来表示

108.spring boot 有哪些方式可以实现热部署？
- 使用devtools启动热部署，添加devtools库，在配置文件中把spring.devtools.restart.enabled设置为true；
- 使用Intellij Idea 编译器，勾上自动编译或手动重新编译
- 

109.jpa 和 hibernate 有什么区别？
- jpa全程Java Persistence API，是Java持久化接口规范，hibernate属于jpa的具体实现。

110.什么是 spring cloud？
- spring cloud是一系列框架的有序集合。它利用spring boot的开发便利性巧妙地简化了分布式系统基础设施的开发，
如服务风险注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以使用spring boot的开发风格做到一键启动和部署。

111.spring cloud 断路器的作用是什么？
- 类似分布式架构中的断路器模式作用，当某个服务器单元发生故障(雷死用电器发生短路)之后，通过断路器的故障监控(类似熔断保险丝)，向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中蔓延

112.spring cloud 的核心组件有哪些？
- Eureka：服务注册于发现
- Feign：基于动态代理机制，根据注解和选择的机器，拼接请求url地址，发起请求
- Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。
- Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题
- Zuul：网关管理，由Zuul网关转发请求给对应的服务；


十二、Hibernate

113.为什么要使用 hibernate？

114.什么是 ORM 框架？

115.hibernate 中如何在控制台查看打印的 sql 语句？

116.hibernate 有几种查询方式？

117.hibernate 实体类可以被定义为 final 吗？

118.在 hibernate 中使用 Integer 和 int 做映射有什么区别？

119.hibernate 是如何工作的？

120.get()和 load()的区别？

121.说一下 hibernate 的缓存机制？

122.hibernate 对象有哪些状态？

123.在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？

124.hibernate 实体类必须要有无参构造函数吗？为什么？

十三、Mybatis

125.mybatis 中 #{}和 ${}的区别是什么？
- #{}是预编译处理，相当于"?"占位符，安全性高
- ${}纯字符串，有SQL注入的安全隐患；

126.MyBatis 有几种分页方式？
1. 逻辑分页：使用MyBatis自带的RowBounds进行分页，原理是一次性查询很多数据，然后在数据中再进行检索。
2. 物理分页：自己手写SQL分页，或使用分页插件PageHelper，去数据库查询指定条数的分页数据；



127.RowBounds(自带分页) 是一次性查询全部结果吗？为什么？
- RowBounds表面是在"所有"数据中检索数据，实际是根据在JDBC驱动中的Fetch Size，规定最多的查询数据条数，假如需要更多数据，只有在调用next()的时候，才会去查询更多的数据。
- 可以有效的防止内存溢出；

128.mybatis 逻辑分页和物理分页的区别是什么？
- 逻辑分页内存开销大，数据量小的情况效率比比物理分页高，数据量大时，则容易内存溢出
- 物理分页，内存开销比较小，在数据量比较小的情况下效率比逻辑分页低，大的时候，建议使用物理分页

129.mybatis 是否支持延迟加载？延迟加载的原理是什么？
- 支持延迟加载，设置lazyLoadingEnabled=true即可；
- 延迟加载的原理是调用的时候触发加载，而不是在初始化的时候就加载信息；
- 即在调用对应的get()方法的时候才进行SQL语句的执行；

130.说一下 mybatis 的一级缓存和二级缓存？
- 一级缓存：基于PerpetualCache的HashMap本地缓存，它的声明周期是和SQLSession一致的，有多个SQLSession或者分布式的环境中数据库操作，可能会出现脏数据。当Session flush 或 close之后，该Session中的所有Cache就将清空，默认一级缓存是开启的。
- 二级缓存：同样基于PerpetualCache的HashMap本地缓存，不同在于其存储作用域为Mapper级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口

131.mybatis 和 hibernate 的区别有哪些？
- MyBatis 更加灵活，自己可以写SQL语句；
- 可移植性：MyBatis的SQL是自己写的，因此移植性差；
- MyBatis使用门槛低，简单
- hibernate有更好的二级缓存，可以自行更换为第三方的二级缓存

132.mybatis 有哪些执行器（Executor）？(三种)
- TODO

133.mybatis 分页插件的实现原理是什么？


134.mybatis 如何编写一个自定义插件？

十四、RabbitMQ

135.rabbitmq 的使用场景有哪些？

136.rabbitmq 有哪些重要的角色？

137.rabbitmq 有哪些重要的组件？

138.rabbitmq 中 vhost 的作用是什么？

139.rabbitmq 的消息是怎么发送的？

140.rabbitmq 怎么保证消息的稳定性？

141.rabbitmq 怎么避免消息丢失？

142.要保证消息持久化成功的条件有哪些？

143.rabbitmq 持久化有什么缺点？

144.rabbitmq 有几种广播类型？

145.rabbitmq 怎么实现延迟消息队列？

146.rabbitmq 集群有什么用？

147.rabbitmq 节点的类型有哪些？

148.rabbitmq 集群搭建需要注意哪些问题？

149.rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？

150.rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？

151.rabbitmq 对集群节点停止顺序有要求吗？

十五、Kafka

152.kafka 可以脱离 zookeeper 单独使用吗？为什么？

153.kafka 有几种数据保留的策略？

154.kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？

155.什么情况会导致 kafka 运行变慢？

156.使用 kafka 集群需要注意什么？

十六、Zookeeper

157.zookeeper 是什么？

158.zookeeper 都有哪些功能？

159.zookeeper 有几种部署模式？

160.zookeeper 怎么保证主从节点的状态同步？

161.集群中为什么要有主节点？

162.集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？

163.说一下 zookeeper 的通知机制？

十七、MySql

164.数据库的三范式是什么？
- 第一范式：数据库表每一列都是不可分割的原子数据项
- 第二范式：要求实体的属性==完全依赖==于主关键字。例如(key1,key2) -> Object ; 不可以有 key1/key2 -> Object
- 第三范式：任何非主属性不依赖于其他非主属性；
- BCNF：组合主键不可以相互依赖：譬如(key1,key2) 不可以有 key1 -> key2

165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？
- 表类型如果是MyISAM，那id就是8。
- InnoDB，那就是6，因为InnoDB表只会把自增主键的最大id记录在内存中，所以重启之后会导致最大id丢失；

166.如何获取当前数据库版本？
- 使用select version();

167.说一下 ACID 是什么？
- Atomicity (原子性)：事务所有操作或者完成，或者全部不完成；
- Consistency (一致性)： 事务不破坏数据库的完整性(合理性)
- Isolation (隔离性)：事务与事务之间不相互影响；
- Durability (持久性)：数据的修改不会随着断电丢失

168.char 和 varchar 的区别是什么？
- char：固定长度占用；会存储多余的空字节
- 优点：效率高，缺点：占用空间多；使用场景：存储密码的md5值，固定长度；
- varchar:长度可变，节省空间；每二个占用的字节再加上一个用于记录长度的字节的长度

169.float 和 double的区别是什么？
- float最多可以存储8位的十进制数，在内存中占4字节
- double最多可以存储16位的十进制数，在内存中占8字节

170.mysql 的内连接、左连接、右连接有什么区别？
- 内连接关键字：inner join ； 左连接：left join ； 右连接 right join
- 内连接：左右均匹配；左/右连接是左/右表全显示，另一边匹配的数据可为null

171.mysql 索引是怎么实现的？
- 主流使用B+树实现；
- 

172.怎么验证 mysql 的索引是否满足需求？
- 使用explain查看SQL是如何执行查询语句的，分析是否使用了索引；
- explain select * from table where xxxxxxxxx
- 

173.说一下数据库的事务隔离？
- 事务隔离是在MySQL.ini配置文件里添加的，在文件的最后添加：
- transaction-isolation = REPEATABLE-READ
- 可用的配置值：READ-UNCOMMITED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE

174.说一下 mysql 常用的引擎？
- InnoDB引擎：InnoDB引擎提供了对数据库acid事务的支持，默认支持行级锁，也支持表级锁；
- 设计的目的服务于处理大数据容量的数据库；
- InnoDB会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索的，启动速度也比较慢；
- ==锁粒度较小，写操作是不会锁全表的==有利于高并发场景提高效率
- MyISAM引擎：MySQL的默认引擎
- 不支持事务，不支持行级锁和外键，==只支持表级锁==
- MyISAM引擎保存了表的行数，于是当进行select count(*) from table 语句时，可以直接读取已保存的值，而不需要进行全表搜索；
- 因此适用于表的读操作远多于写操作时，且不需要支持事务的情况；

175.说一下 mysql 的行锁和表锁？
- InnoDB默认行级锁，也支持表级锁；MyISAM只支持表级锁
- 表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率高，并发量最低(并发处理效率)
- 行级锁：开销大，加锁慢，会出现死锁，锁的粒度小，锁冲突概率小，并发量最高(并发处理效率高)
- 
176.说一下乐观锁和悲观锁？
- 乐观锁：认为拿的数据不会被其他线程修改，因此不会上锁，仅记录versionid(类似对象头里面的threadid),在提交数据的时候，会检查一下versionid是否一致，来判断数据是否已被更改了；
- 悲观锁：认为拿的数据都会被人修改，所以==在读取数据的时候==就会上锁；直到数据处理并写入完毕；
- 



177.mysql 问题排查都有哪些手段？
- 开启慢查询日志，查找慢查询的SQL； ★★★★
- 使用 show processlist命令查看当前所有连接信息；
- 使用explain命令查询SQL执行情况；


178.如何做 mysql 的性能优化？
- 为搜索字段创建索引
- 避免范围搜索，尽量使用精确查找；避免全表搜索
- 垂直分割分表
- 选择正确的存储引擎
- 


十八、Redis

179.redis 是什么？都有哪些使用场景？
- redis是一个使用C语言开发的高速缓存数据库；
- 使用场景：1.记录帖子的点赞数、点击数、评论数；
- 缓存近期热帖；
- 缓存文章详细信息；
- 记录用户会话信息；

180.redis 有哪些功能？
- 数据缓存
- 实现分布式锁
- 支持事务
- 支持消息队列

181.redis 和 memecache 有什么区别？
- 存储方式不同：memcache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型：memcache对数据类型支持相对简单；==Redis 有复杂的数据类型==。
- 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了vm机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
- value 值大小不同：Redis 最大可以达到 1gb；memcache 只有 1mb。

182.redis 为什么是单线程的？
- 因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

183.什么是缓存穿透？怎么解决？
- 缓存穿透：指查询一个一定不存在的的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将==导致这个不存在的数据每次请求都要到数据库去查询==，造成缓存穿透
- 解决方案：短时间缓存空结果查询

184.redis 支持的数据类型有哪些？
- string、list、hash、set、zset(有序集合)

185.redis 支持的 java 客户端都有哪些？
- Redisson、jedis、lettuce
- java用于操作redis的依赖函数库

186.jedis 和 redisson 有哪些区别？
- jedis：提供了比较全面的Redis命令的支持
- Redisson：实现了分布式和可扩展的Java数据集结构，与Jedis相比，Redisson的功能相对简单，不支持排序、事务、管道、分区等Redis特性

187.怎么保证缓存和数据库数据的一致性？
- 合理设置缓存的过期时间
- 新增、更改、删除数据库操作时同步更新Redis，可以用事务机制来保证数据的一致性
- 


188.redis 持久化有几种方式？
- RDB：指定的时间间隔能对你的数据进行快照存储
- AOF：每一个受到的写命令都通过write函数追加到文件中
- 


189.redis 怎么实现分布式锁？
- Redis分布式锁其实就是在系统里面占一个"坑"；即线程获取锁成功就执行，失败就等待或重新尝试；
- 一般使用setnx指令，使用完调用del释放锁；底层保证了原子性，和锁超时，和自动延时

190.redis 分布式锁有什么缺陷？
- Redis分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题；(自动延时)

191.redis 如何做内存优化？
- 尽量使用Redis的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储；可节省开销；即封装(一个整体)后存储；

192.redis 淘汰策略有哪些？
- volatile-lru：从已设置过期时间的数据集中挑选最近==最少使用的==数据淘汰；
- volatile-ttl：从已设置过期时间的数据集中挑选==将要过期的==素具淘汰；
- allkeys-lru：从数据集中挑选==最少使用==的数据淘汰；
- allkeys-random：从数据集中任意选择数据淘汰。
- no-enviction(驱逐)：禁止驱逐数据

193.redis 常见的性能问题有哪些？该如何解决？
- 主服务器写内存快照，会阻塞主线程的工作，当快照比较大的时候对性能影响很大，会间断性暂停服务，所以主服务器最好不用写内存快照
- Redis主从复制的性能问题，主从库最好在同一个局域网内，有利于保证速度和稳定性

十九、JVM

194.说一下 jvm的主要组成部分？及其作用？
- 类加载器(ClassLoader)
- 运行时数据区(Runtime Data Area)
- 执行引擎(Execution Engine)
- 本地库接口(Native Interface)
- 执行流程：类加载器，把Java代码转换成字节码，运行时数据区把字节码加载到内存(JVM)中；通过特定的命令解析器执行引擎，把字节码翻译成底层系统指令，再交给CPU执行；而这个过程需要调用其他语言的本地库接口来实现整个程序的功能；

195.说一下 jvm 运行时数据区(内存模型)？
- 线程共享：
- 方法区(元空间可实现该功能)：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据；
- 堆(元空间(永久代)，老年代，年轻代)：内存最大的一块，几乎所有的对象实例都在这里进行分配内存；
- 非线程共享：
- 程序计数器：用于记录当前执行字节码的行号；用于选取下一跳需要执行的字节码指令，可实现分支、循环、跳转、异常处理、现场恢复等基础功能；
- Java虚拟机栈：用于存储==局部变量表、操作数栈、动态链接、方法出口==等信息；
- 本地方法栈：用处同上，不过针对Native方法；
- JDK8 没有永久代，只有元空间(方法区的一种实现)了


196.说一下堆栈的区别？
- 功能方面：堆是用来存放对象的，栈是用于执行程序的；
- 共享性；堆是线程共享的，栈是线程私有的；
- 空间大小：堆空间远大于栈空间


197.队列和栈是什么？有什么区别？
- 队列和栈均是用于存储数据的；
- 队列允许先进先出；栈是先进后出；
- 

198.什么是双亲委派模型？
- 说明：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器都有一个独立的类名称空间。类加载器就是根据指定全限定名称将class文件加载到JVM内存中，然后再转化成class对象；
- 类加载器分类：
- 启动类加载器：虚拟机自身的一部分，用于加载Java_HOME/lib/目录中的基本包；或者被-Xbootclasspath参数所指定的路径中被虚拟机识别的类库；
- 其他类加载器：
- 扩展类加载器：责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；
- 应用程序加载器：负责加载用户类路径上指定的类库，我们可以直接使用这个类加载器(默认)。
- 
- 双亲委派模型：如果一个类加载器受到了类加载的请求，它**首先**不会自己去加载这个类，==而是把这个请求委派给父类加载器==去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载器无法完成加载请求(无法找到)时，子加载器才会去尝试加载类；

199.说一下类加载的执行过程？
- 加载：根据路径找到相应的class文件然后导入；
- 检查：检查加载的class文件的正确性；
- 准备：给类中的的静态变量分配内存空间；
- 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。(真正地指向物理内存，而不是作为一个标识的存在)
- 初始化：对静态变量和静态代码块进行初始化工作；

200.怎么判断对象是否可以被回收？(前两点)
- 引用计数回收法：利用==引用计数器==，有引用则记录(+1)；当引用存在数量为0时，则回收；缺点：无法回收对象相互引用的情况；(有点像逃逸分析)
- 跟踪回收算法：进行==可达性分析==，从根(main)遍历，无法达到的对象就会被回收；
- ==压缩回收算法==(标记-回收算法)：按照存活对象在内存的顺序，依次进行排序在内存中整理位置；剩下的空间进行垃圾回收；(适用于老年代)
- ==复制回收算法==：分成两部分(或更多)，把存活的对象依次移动到另一个子堆(年龄+1)，然后回收资源；(多用于年轻代)
- 按代回收算法(主流)：
- 分成多个子堆(两个以上):复制回收算法的思想；按照代存活时间(稳定性)来决定遍历次数；
- 新生代1/3(8/10Eden + 1/10from + 1/10to) + 老年代2/3 
- JDK8，元空间取代了永久代

201.java 中都有哪些引用类型？
- 强引用：发生gc的时候不会被回收。
- 软引用：有用但不是必需的对象：在发生内存溢出之前会被回收
- 弱引用：有用但不是必需的对象：在下一次GC时被回收
- 虚引用：无法获得具体的对象；用于GC时返回通知？ //TODO

202.说一下 jvm 有哪些垃圾回收算法？
- 同上

203.说一下 jvm 有哪些垃圾回收器？
- Serial：最早的单线程串行垃圾回收期
- Serial Old：上述的老年版本，可作为CMS垃圾回收期的备选预案
- ParNew：是Serial的多线程版本
- Parallel和ParNew收集器类似，是多线程的，Parallel是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量；
- Parallel Old是Parallel 老年代版本，Parallel使用的是复制回收算法，Parallel Old使用的是压缩回收算法(标记-整理)
- CMS：一种以获得最短停顿时间为目标的收集器，非常适合B/S系统
- G1：兼顾吞吐量和停顿时间的GC实现，是JDK9后默认的GC选项；


204.详细介绍一下 CMS 垃圾回收器？
- CMS是英文Concurrent Mark-Sweep 的简称，以牺牲吞吐量为代价来换取最短回收停顿时间；适用于对服务器相应速度要求高的应用；
- 启动时通过“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器
- 使用的是标记-清除算法实现的，所以在GC的时候会产生大量的内存碎片，当剩余内存不能满足程序运行要求时，会临时采用Serial Old回收器来进行垃圾清除，此时的性能会降低；

205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
- 新生代回收器：Serial，ParNew、Parallel Scavenge
- 老年代回收器：Serial Old、Parallel Old、CMS
- 整堆回收器：G1

206.简述分代垃圾回收器是怎么工作的？
- 分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。
> D:\桌面的各种文件夹\File_simple\编译原理\1711104-20190710115458004-1019173364.png
- 年轻代使用的是复制回收算法；年轻代有三个子堆，最小的两个子堆1/10，在From Survivor 和 To Survivor分区交替复制回收资源的过程，每次移动年龄均会+1，默认15进入老年代；==大对象会直接进入老年代；(因此要避免短命大对象==)
- 老年代使用的一般是标记-回收(压缩回收)算法；
- 

207.说一下 jvm 调优的工具？
- jconsole 用于对JVM中的内存、线程和类进行监控；
- jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、线程死锁、监控内存的变化、GC变化等；

208.常用的 jvm 调优的参数都有哪些？
- Xm==s==2g： 初始化堆大小为2g
- Xm==x==2g：堆最大内存为2g
- -XX:NewRatio=4：设置年轻代和老年代的内存比例为1：4
- -XX:SurvivorRatio=8：设置新生代Eden和Survivor内存比例为8:2,Survivor一分为二：From区和To区；
- -XX:+UseParNewGC：使用ParNew + Serial Old
- -XX:+UseParallelOldGC：使用ParNew + ParNew Old
- -XX:+UseConcMarkSweepGC：使用CMS + Serial Old
- -XX:+PrintGC：开启打印gc信息；
- -XX:+PrintGCDetails：打印gc详细信息；

---



个人补充
---
215.子类必须使用super();调用父类的构造函数吗？
- 如果父类存在带参数的构造函数，而你又没有在父类中添加空的构造函数 ，子类就要显式的调用父类的构造函数。
- 否则默认调用super();

214.HashMap 和 HashTable
- HashMap线程不安全，数组+链表+红黑树，key和value可以为null
- Hashtable线程安全，实现原理是锁住整个对象，数组+链表
- ConcurrentHashMap线程安全，CAS+同步锁，数组+链表+红黑树

- 普通线程安全的hashMap实现原理是通过mutex互斥锁，直接加入sychronized；效率低
```
Map safeMap = Map.sychronizedMap(hashMap);
```
- ConcurrentHashMap：通过分段锁Segment来实现，譬如数组+链表，锁粒度控制在链表里，其他数组可以继续获取锁进行操作
- 它进一步的优化是，数组+链表+红黑树，即链表内链表数量超出一定数量时候自动转为红黑树；
- 不允许插入null

213.ABA问题是什么？
- 乐观锁操作是根据比对数据是否与预期一致来进行的，如果修改为B再改回A，即使是A，但也不是原来的A，会存在安全隐患，一般是使用versionID来处理，或者内存地址

212.J.U.C是什么？
- J.U.C的atomic包提供了常用的原子性数据类型以及引用，数组等相关原子类型和更新操作工具，是很多线程安全程序的首选
- Unsafe类虽能提供CAS服务，但因能够操纵任意内存地址而村咋子隐患
- 知识点梳理：
- 提供并发变成的解决方案CAS：atomic,和AQS ：Semophore,ReentrantLock
- 线程执行器executor
- 锁locks
- 原子变量类atomic
- 并发工具类tools:四个同步器：①闭锁CountDownLatch，②栅栏CyclicBarrier，信号量Semaphore，交换器Exchanger 用于协助同步；
- ① 让主线程等待一组事件发生后继续执行，用法，在run()方法执行完毕调用主线程给每一个线程任务的countDownLatch锁的countDown()方法；
- ② 阻塞当前线程，等待其他线程，等所有线程到达栅栏处，可以触发执行另一个预先设置的线程，用法同上
- 并发集合collections
- 


211.CAS是什么？

210.用户态和操作态？


209.jit编译器和javac编译器(解析器)的区别？

- jit编译器：负责把.class文件翻译成==本地==机器字节码



- javac编译器：把编写的代码翻译成.class文件


这两种方式可以说是各有优势，虚拟机(特指HotSpot虚拟机)在执行的时候，一般会采用两种方式结合的策略。

也就是说，在程序执行的时候，有些代码采用解释器的方式，有些代码采用编译器，称之为即时编译。一般我们会对热点代码采用编译器的方式。


热点代码主要有以下两类：
- 被多次调用的方法。


- 被多次执行的循环体。


**两种方法的优缺点：**

显然第一种方法在实现上是比较简单、高效的，但是缺点也很明显，精确度不高，容易受到线程阻塞等别的外界因素的干扰。

第二种方式的统计结果会很精确，但需要为每个方法建立并维护一个计数器。实现上会相对复杂一点并且开销也会大点。

不过，这里需要指出的是，我们的HotSpot虚拟机采用的是基于计数器的方式。

>说明：虚拟机在执行方法的时候，会先判断该方法是否存在已经编译好的版本，如果存在，则执行编译好的本地机器码，否则，采用一边解释一边编译的方式。

各种编译优化策略

我们刚才已经说了，对于有些被多次调用的方法或者循环体，虚拟机会先把他们编译成本地机器码。由于这些热点代码都是一些会被多次重复执行的代码，为了使得编译好的代码更加完美，运行更快。编译器做了很多的编译优化策略，例如上面的无用代码消除就是其中的一种。

下面我们来讲讲大概都有哪些优化策略：

大概预览一波：

- 公共子表达式消除。

- 数组范围检查消除。

- 方法内联。

- 逃逸分析。


(1).公共子表达式消除

我们来举个例子。例如

int d = (c * b) * 10 + a + (a + b * c);

这段代码到了即时编译器的手里，它会进行如下优化：

表达式中有两个 b * c的表达式，并且在计算期间b与c的值并不会变。所以这条表达式可能会被视为：

int d = E * 10 + a+ (a + E);

接着继续优化成

int d = E * 11 + a + a;

接着

int d = E * 11 + 2a;

这样，代码在执行的时候，就会节省了一些时间了。

>原文更多：https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485264&amp;idx=1&amp;sn=1278076a067d1464c92bb0ce6ebe53b6&source=41#wechat_redirect