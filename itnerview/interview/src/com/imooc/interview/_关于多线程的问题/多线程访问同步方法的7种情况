1.两个线程同时访问一个对象的同步方法     - 正常运行，依次执行
2.两个线程的是两个实例对象的同步方法     - 不起作用
3.两个线程访问的是synchronized的静态方法 - 正常运行，虽有实例对象只有一个可以运行
4.同时访问同步方法和非同步方法(被synchronized修饰和没被synchronized修饰的)
5.访问一个对象的不同的普通同步方法
    * synchronized 修饰普通方法，实际上等同于 synchronized(this) ,而且是方法之间共用一把锁；因此不会同时执行
6.同时访问静态synchronized和非静态synchronized方法
    * 本质是：类锁和对象锁，因为不是同一把锁，因此不会同步执行；
7.方法抛出异常，会释放锁？(Lock锁抛出异常，依旧不会释放锁，需要手动unlock)
    * 一旦抛出了异常(RuntimeException)，第二个线程会立刻进入并运行；
    * JVM会帮助释放对应的锁
    * 原理：根据字节码：monitor

总结：
    - 一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待；(对应1、5)
    - 每个实例对象(Object)都对应有自己的一把锁(可以提供给线程)
    - 不同实例对象的锁不会相互影响；(Class.class也可以算是一个实例对象，也就是所说的类锁)
    - 类锁和对象锁也互不影响，因为不是同一把锁；重点★★★★★

    *  - 在synchronized方法内调用其他对象的非synchronized方法，不是线程安全的；